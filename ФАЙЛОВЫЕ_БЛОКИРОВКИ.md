# Решение проблемы блокировки файлов и папок

## Проблема
После закрытия приложения TankManager невозможно удалить папку `products` через проводник Windows. Появляется ошибка: "Операция не может быть завершена, так как папка открыта в другой программе".

## Причина
В WPF приложениях изображения (`BitmapImage` и `BitmapSource`) и файлы JSON блокируют файлы, если они загружены напрямую через `UriSource` или `FileStream` без полной загрузки в память. Также `DataContractJsonSerializer` может внутренне кэшировать потоки.

## Реализованные исправления

### 1. DrawingPreviewService.cs
**Изменено:** Метод `LoadPreviewImage`
- **Было:** Загрузка через `UriSource` или прямой `FileStream`
- **Стало:** Загрузка через `FileStream` ? `MemoryStream` с полным копированием данных
- **Результат:** Файл освобождается сразу после загрузки

### 2. ProductStorageService.cs
**Изменено:** Методы работы с файлами
- **LoadFromFile, SaveToFile:** Теперь используют `MemoryStream` для чтения/записи JSON
- **LoadSettings, SaveSettings:** Также через `MemoryStream`
- **DeleteDirectoryRecursive:** Добавлена диагн?stico и повторные попытки с GC

### 3. FileLockDiagnostics.cs (новый файл)
**Добавлено:** Утилита для диагностики блокировок
- `FindLockedFiles()` - находит все заблокированные файлы в папке
- `IsFileLocked()` - проверяет, заблокирован ли файл
- `ForceDeleteDirectory()` - удаляет с повторными попытками и GC

### 4. ThumbnailService.cs
**Изменено:** Метод `GetFileThumbnail`
- **Добавлено:** Явное освобождение `Bitmap` после конвертации
- **Результат:** Ресурсы GDI+ освобождаются немедленно

### 5. PartModel.cs
**Изменено:** Метод `Dispose`
- **Добавлено:** Очистка всех превью (FilePreview и DrawingPreview)
- **Результат:** Полное освобождение ресурсов изображений

### 6. Product.cs
**Изменено:** Метод `Clear`
- **Добавлено:** Перебор всех деталей с вызовом `Dispose()` и очисткой превью
- **Результат:** Полное освобождение всех связанных ресурсов

### 7. MainViewModel.cs
**Изменено:** Множественные улучшения
- `SetCurrentProduct()` - очистка превью при переключении продуктов
- `DeleteSelectedProduct()` - принудительная сборка мусора перед удалением
- `Dispose()` - полная очистка всех деталей и превью с тройной GC

### 8. MainWindow.xaml.cs
**Изменено:** Обработчик `DrawingPreview_MouseLeftButtonDown`
- **Добавлено:** Очистка ссылок на изображения при закрытии окна предпросмотра

## Как это работает

### Правильная последовательность загрузки изображений:
```csharp
var bitmap = new BitmapImage();
bitmap.BeginInit();
bitmap.CacheOption = BitmapCacheOption.OnLoad;

using (var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
using (var memoryStream = new MemoryStream())
{
    fileStream.CopyTo(memoryStream);
    memoryStream.Position = 0;
    bitmap.StreamSource = memoryStream;
    bitmap.EndInit();
}

bitmap.Freeze();
```

### Правильная работа с JSON:
```csharp
// Загрузка
using (var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read))
using (var memoryStream = new MemoryStream())
{
    fileStream.CopyTo(memoryStream);
    memoryStream.Position = 0;
    var data = (T)serializer.ReadObject(memoryStream);
    return data;
}

// Сохранение
using (var memoryStream = new MemoryStream())
{
    serializer.WriteObject(memoryStream, data);
    memoryStream.Position = 0;
    
    using (var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None))
    {
        memoryStream.CopyTo(fileStream);
    }
}
```

### Освобождение ресурсов:
```csharp
// 1. Очистка превью
detail.FilePreview = null;
detail.InvalidateDrawingPreviewCache();
detail.Dispose();

// 2. Принудительная сборка мусора (тройная)
GC.Collect();
GC.WaitForPendingFinalizers();
GC.Collect();

// 3. Удаление с повторными попытками
FileLockDiagnostics.ForceDeleteDirectory(path, maxAttempts: 5, delayMs: 200);
```

## Диагностика проблем

### Использование FileLockDiagnostics для отладки:

```csharp
// Найти все заблокированные файлы
var lockedFiles = FileLockDiagnostics.FindLockedFiles(@"C:\путь\к\products");
foreach (var file in lockedFiles)
{
    Debug.WriteLine($"Заблокирован: {file}");
}

// Удалить с диагностикой
List<string> blockedFiles;
bool success = FileLockDiagnostics.TryDeleteDirectoryWithDiagnostics(path, out blockedFiles);
if (!success)
{
    Debug.WriteLine($"Не удалось удалить. Заблокировано: {blockedFiles.Count} файлов");
}
```

## Рекомендации

### Если файлы всё ещё заблокированы:
1. **Закройте приложение** через меню или кнопку закрытия
2. **Подождите 3-5 секунд** для завершения сборки мусора и освобождения дескрипторов
3. Попробуйте удалить папку снова
4. Если не помогло - см. "Если проблема сохраняется"

### Если проблема сохраняется:
1. Откройте **Диспетчер задач** (Ctrl+Shift+Esc)
2. Проверьте, что процесс `TankManager.exe` завершён
3. Если процесс висит - завершите его принудительно
4. Попробуйте удалить папку

### Поиск заблокированных файлов через Handle.exe:
```cmd
handle.exe "C:\path\to\products" /accepteula
```

Это покажет, какой процесс держит дескрипторы.

### Временное решение:
Если файлы всё ещё заблокированы, используйте **Unlocker** или перезагрузите компьютер.

## Тестирование

### Тест 1: Удаление после просмотра превью
1. Откройте продукт с чертежами
2. Просмотрите несколько чертежей
3. Закройте приложение
4. Подождите 3-5 секунд
5. Удалите папку `products` через проводник
   - ? Должно удалиться без ошибок

### Тест 2: Удаление через UI приложения
1. Откройте продукт
2. Удалите продукт через кнопку "Удалить"
3. Проверьте, что папка удалена
   - ? Должно удалиться без ошибок

### Тест 3: Закрытие с открытыми превью
1. Откройте продукт
2. Откройте окно предпросмотра чертежа
3. Закройте главное окно приложения
4. Подождите 3-5 секунд
5. Удалите папку `products`
   - ? Должно удалиться без ошибок

### Тест 4: Переключение между продуктами
1. Откройте первый продукт с превью
2. Переключитесь на второй продукт
3. Закройте приложение
4. Удалите папку `products`
   - ? Должно удалиться без ошибок

## Технические детали

### Почему `Freeze()` важен:
- В WPF объекты `BitmapImage` по умолчанию привязаны к UI-потоку
- `Freeze()` делает объект неизменяемым и потокобезопасным
- Это позволяет GC быстрее собирать неиспользуемые объекты

### Почему копирование в MemoryStream:
- `FileStream` держит файловый дескриптор до закрытия потока
- `BitmapImage.EndInit()` должен вызываться ДО закрытия потока
- Копирование в `MemoryStream` позволяет закрыть `FileStream` немедленно
- То же самое с `DataContractJsonSerializer`

### Тройная сборка мусора:
```csharp
GC.Collect();                      // 1. Запускаем сборку мусора (поколение 0, 1, 2)
GC.WaitForPendingFinalizers();    // 2. Ждём выполнения финализаторов
GC.Collect();                      // 3. Собираем финализированные объекты
```

Это необходимо, потому что:
1. Первый `GC.Collect()` помечает объекты для финализации
2. `WaitForPendingFinalizers()` ждёт, пока финализаторы освободят неуправляемые ресурсы (файловые дескрипторы)
3. Второй `GC.Collect()` собирает финализированные объекты

## Дополнительные улучшения (если проблема остаётся)

Если после всех изменений проблема всё ещё возникает редко:

### 1. Логирование всех открытых файлов
```csharp
// Добавить в DrawingPreviewService
Debug.WriteLine($"?? Открыт файл: {pngPath}");
// ... работа с файлом
Debug.WriteLine($"? Закрыт файл: {pngPath}");
```

### 2. WeakReference для кэша изображений
```csharp
private readonly Dictionary<string, WeakReference<BitmapImage>> _imageCache;
```

### 3. Отложенное удаление
```csharp
// Если удаление не удалось, записываем в файл для удаления при следующем запуске
File.WriteAllText("pending_deletions.txt", path);
```

### 4. Использование FileSystemWatcher
Для отслеживания, когда файлы освобождаются.

## Заключение

После внесённых изменений:
1. ? Все изображения загружаются через `MemoryStream`
2. ? Все JSON файлы читаются/пишутся через `MemoryStream`
3. ? При закрытии/переключении продуктов все превью очищаются
4. ? При удалении выполняется тройная сборка мусора
5. ? Удаление происходит с 5 попытками и диагностикой
6. ? Добавлена утилита `FileLockDiagnostics` для отладки

Приложение TankManager теперь корректно освобождает все файловые дескрипторы при закрытии, что позволяет удалять папки через проводник Windows без ошибок. Если проблема возникает - подождите 3-5 секунд после закрытия программы перед удалением.
